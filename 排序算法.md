# 排序算法

## 1. 冒泡排序

### 1.1 传统冒泡

依次比较相邻的两个元素，按照升序或者降序的规则进行交换，一轮冒泡结束后，最大（升序）/最小（降序）的元素会被冒泡到数组的最后，下一轮冒泡次数相应的减少一次。

```cpp
#include <iostream>
#include <vector>

using namespace std;

class Solution {
public:
    vector<int> bubbleSort(vector<int> arr) {
        // 外层循环：控制冒泡的轮数（趟数）
        // 每完成一轮，就会有一个最大的元素"冒泡"到正确位置
        // 总共需要 n-1 轮（n为数组长度），因为最后一个元素自然就是最小的
        for (int i = 0; i < arr.size() - 1; i++) {
            // 内层循环：负责在每一轮中进行相邻元素的比较和交换
            // j < arr.size() - 1 - i 的原因：
            // 1. arr.size() - 1：因为比较的是 arr[j] 和 arr[j+1]
            //    所以 j 最大只能到倒数第二个元素，避免数组越界
            // 2. - i：经过 i 轮后，数组末尾已经有 i 个元素排好序了
            //    这些已排序的元素不需要再参与比较，所以减少比较次数
            for (int j = 0; j < arr.size() - 1 - i; j++) {
                // 如果前面的元素大于后面的元素，交换它们
                if (arr[j] > arr[j + 1]) {
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }
            }
        }
        return arr;   // 返回排好序的数组
    }
};

// 主函数示例
int main() {
    Solution s;
    vector<int> arr = { 6,2,3,4,0 };
    cout << "before sorted: ";
    for (int i = 0; i < arr.size(); i++) {
        cout << arr[i] << " ";
    }
    cout << endl;

    vector<int> sorted_arr = s.bubbleSort(arr);   // 调用函数
    cout << "after sorted: ";
    for (int i = 0; i < sorted_arr.size(); i++) {
        cout << sorted_arr[i] << " ";
    }
    cout << endl;
    return 0;
}
```

### 1.2 冒泡优化

```cpp
class Solution {
public:
    vector<int> bubbleSort(vector<int> arr) {

        bool is_swaping = false;   // 用来标记这一轮冒泡是否发生了交换，如果没有发生交换，说明数组已经有序，可以直接跳出外循环

        // 外层循环：控制冒泡的轮数（趟数）
        // 每完成一轮，就会有一个最大的元素"冒泡"到正确位置
        // 总共需要 n-1 轮（n为数组长度），因为最后一个元素自然就是最小的
        int i;
        for (i = 0; i < arr.size() - 1; i++) {
            // 内层循环：负责在每一轮中进行相邻元素的比较和交换
            // j < arr.size() - 1 - i 的原因：
            // 1. arr.size() - 1：因为比较的是 arr[j] 和 arr[j+1]
            //    所以 j 最大只能到倒数第二个元素，避免数组越界
            // 2. - i：经过 i 轮后，数组末尾已经有 i 个元素排好序了
            //    这些已排序的元素不需要再参与比较，所以减少比较次数
            for (int j = 0; j < arr.size() - 1 - i; j++) {   // 
                if (arr[j] > arr[j + 1]) {
                    is_swaping = true;   // 发生了交换
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }
            }
            if (is_swaping) {   // 发生了交换，说明数组还不是有序状态，重置is_swaping，继续循环
                is_swaping = false;
            }
            else {
                break;
            }
        }
        cout << "循环了 " << i << " 轮" << endl;
        return arr;
    }
};
```

## 2. 选择排序

从**待排序的数据元素**中选择最小（或最大）的一个元素，存放在序列的**起始位置（或末尾）**，直到待排序元素的个数为0.

选择排序是**不稳定**的排序算法，不稳定性源于他的**交换机制**。因为选择排序的交换是"**跳跃式**"的，这种长距离的交换无法保证相等元素的相对顺序。

### 2.1 理解什么是排序算法的稳定性

如果排序算法能够保证**相等元素**在排序前后的**相对顺序**不变，那么这个算法就是稳定的。

```cpp
#include <iostream>
#include <vector>

using namespace std;

class Solution {
public:
    vector<int> selectSort(vector<int> arr) {

        for (int i = 0; i < arr.size() - 1; i++) {   // 选择的轮数，选到倒数第二个元素就可以，因为最后一个就确定好了
            int min_index = i;   // 待排序数组中最小元素的下标
            for (int j = i; j < arr.size(); j++) {
                if (arr[min_index] > arr[j]) {
                    min_index = j;   // 更新值
                }
            }
            if (min_index != i) {
                int temp = arr[min_index];
                arr[min_index] = arr[i];
                arr[i] = temp;
            }
        }
        return arr;
    }
};
```

### 2.2 冒泡和选择的区别

1. 时间复杂度都是$O(n^2)$，空间复杂度都是$O(1)$ 
2. 冒泡是比较相邻两个元素的大小，选择是按顺序寻找最大值或最小值
3. 冒泡排序每一轮比较后，位置不对都需要换位置，选择排序每一轮比较都只需要换一次位置
4. 冒泡排序是通过数去找位置，选择排序是给定位置去找数

## 3. 插入排序

将一个数据插入到已经排好序的有序数组中，适用于少量数据的排序。

时间复杂度$O(n^2)$
空间复杂度$O(1)$

### 3.1 第一次想问题

不是移位进行插入，而是通过交换元素实现，在性能上稍差一些（多了很多交换操作）。

```cpp
class Solution {
public:
    vector<int> insertSort(vector<int> arr) {
        for (int i = 1; i < arr.size(); i++) {
            for (int j = i; j > 0; j--) {
                if (arr[j] >= arr[j - 1]) {
                    break;
                }
                else {
                    int temp = arr[j];
                    arr[j] = arr[j - 1];
                    arr[j - 1] = temp;
                }
            }
        }
        return arr;
    }
};
```

### 3.2 通过移位实现插入

```cpp
class Solution {
public:
    vector<int> insertSort(vector<int> arr) {
        for (int i = 1; i < arr.size(); i++) {
            int key = arr[i];   // 要进行插入的元素，保存下来
            int j = i - 1;   // 有序数组的最后一个元素
            while (j >= 0 && arr[j] > key) {   // j < 0 的话数组会越界，这里必须是和 key 进行比较，arr[i] 会被覆盖掉
                arr[j + 1] = arr[j];
                j--;
            }
            arr[j + 1] = key;   // 上面j--，实际插入位置要在往后一位，举个例子就明白了
        }
        return arr;
    }
};
```

## 4. 希尔排序（Shell Sort）

**按照下标一定增量进行分组，每组再按照插入算法排序**，随着组的减少，每组的元素也越来越少，当组数减少至1时，整个文件分成一组，算法便终止。

**不稳定**，相等的元素可能分到不同的组中，相对顺序可能改变。

```cpp
class Solution {
public:
    vector<int> shellSort(vector<int> arr) {
        int n = arr.size();
        // 外层循环：控制增量gap，从n/2开始，每次减半，直到1
        for (int gap = n / 2; gap > 0; gap /= 2) {
            // 内层循环：对每个gap分组进行插入排序
            for (int i = gap; i < n; i++) {
                int key = arr[i];   // 保存当前要插入的元素
                int j = i - gap;   // 从当前元素的前一个gap位置开始比较

                // 寻找合适的插入位置
                while (j >= 0 && arr[j] > key) {
                    arr[j + gap] = arr[j];   // 元素后移
                    j -= gap;   // 继续向前比较
                }
                arr[j + gap] = key;   // 插入到正确位置
            }

            for (int num : arr) {    // 打印每轮排序结果（调试方式）
                cout << num << " ";
            }
            cout << endl;
        }
        return arr;
    }
};
```

## 5. 快速排序

将要排序的数组分为两部分，左边的都比它小，右边的都比它大，然后递归左右两部分。；

```cpp
#include <iostream>
#include <vector>

using namespace std;

class Solution {
public:
    // 快排函数
    void my_quick_sort(vector<int>& arr, int left, int right) {   
        // 1. 递归终止条件
        if (left >= right) {   // 区间不存在/只有一个元素，位置一定正确
            return;
        }
        // 2. 取基准
        int mid = (left + right) / 2;   // 计算中间索引
        int pivot = arr[mid];   // 基准值
        // 3. 初始化做左右指针
        int l = left, r = right;
        // 4. 分区操作
        while (l <= r) {
            // 从左到右找第一个大于基准的元素
            while (arr[l] < pivot) l++;
            // 从右到左找第一个小于基准的元素
            while (arr[r] > pivot) r--;
            // 找到之后交换两个元素
            if (l <= r) {
                swap(arr[l], arr[r]);
                l++;   // 左指针右移
                r--;   // 右指针左移
            }
        }
        // 5. 递归遍历左右子数组
        my_quick_sort(arr, left, r);
        my_quick_sort(arr, l, right);
    }
};

int main() {
    Solution s;
    vector<int> arr = { 8, 3, 5, 1, 4, 2, 7, 6 };
    cout << "before sorted: ";
    for (int i = 0; i < arr.size(); i++) {
        cout << arr[i] << " ";
    }
    cout << endl;

    s.my_quick_sort(arr, 0, arr.size() - 1);
    cout << "after sorted: ";
    for (int i = 0; i < arr.size(); i++) {
        cout << arr[i] << " ";
    }
    cout << endl;
    return 0;
}
```

## 6. 归并排序

采用**分治法**的一个典型应用。将已有序的子序列合并，得到完全有序的序列。即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并

```cpp
#include <iostream>
#include <vector>

using namespace std;

class Solution {
public:
    // 快排函数
    void my_merge_sort(vector<int>& arr) {   
        if (arr.size() <= 1) {   // 当分的子序列元素为1是，结束
            return;
        }
        
        // 划分区间
        int mid = arr.size() / 2;
        vector<int> left(arr.begin(), arr.begin() + mid);
        vector<int> right(arr.begin() + mid, arr.end());

        // 递归划分区间，直到元素个数为1
        my_merge_sort(left);
        my_merge_sort(right);

        // 合并
        int i = 0, j = 0, k = 0;
        while (i < left.size() && j < right.size()) {
            arr[k++] = (left[i] <= right[j]) ? left[i++] : right[j++];
        }
        while (i < left.size()) {
            arr[k++] = left[i++];
        }
        while (j < right.size()) {
            arr[k++] = right[j++];
        }
    }
};
```

## 7. 基数排序（radix sort）

基数排序是一种**非比较型**的**整数排序算法**，它根据数字的各个位来进行排序。它的核心思想是：**从最低位开始，依次对每一位进行排序**。

```cpp
#include <iostream>
#include <vector>

using namespace std;

class Solution {
public:
    // 快排函数
    void my_radix_sort(vector<int>& arr) {   
        if (arr.empty()) { 
            return;
        }
        
        // 1. 找到最大值，确定最大位数
        int maxNum = *max_element(arr.begin(), arr.end());   // max_element 返回的是指向最大元素的迭代器，而不是元素本身。需要通过解引用操作符 * 获取值。
        int maxDigit = 0;
        while (maxNum > 0) {
            maxNum /= 10;
            maxDigit++;
        }

        // 2. 创建10个桶，对应0-9
        vector<vector<int>> buckets(10);

        // 3. 从低位到高位进行排序
        for (int digit = 0; digit < maxDigit; digit++) {
            // 清空桶
            for (auto& bucket : buckets) bucket.clear();
            // 将数字分配到对应的桶中
            for (int num : arr) {
                int digitVal = (num / (int)pow(10, digit)) % 10;
                buckets[digitVal].push_back(num);
            }
            // 从桶中按顺序手机数组
            int index = 0;
            for (int i = 0; i < 10; i++) {
                for (int num : buckets[i]) {
                    arr[index++] = num;
                }
            }

        }
    }
};

int main() {
    Solution s;
    vector<int> arr = { 170, 45, 75, 90, 802, 24, 2, 66 };
    cout << "before sorted: ";
    for (int i = 0; i < arr.size(); i++) {
        cout << arr[i] << " ";
    }
    cout << endl;

    s.my_radix_sort(arr);
    cout << "after sorted: ";
    for (int i = 0; i < arr.size(); i++) {
        cout << arr[i] << " ";
    }
    cout << endl;
    return 0;
}
```

## 8. 堆排序

堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：

大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；
小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；
堆排序的平均时间复杂度为 Ο(nlogn)。

1. 把无序数组构建成二叉堆
2. 循环删除堆顶元素，移到集合尾部，调节堆产生新的堆项。

```cpp
#include <iostream>
#include <vector>

using namespace std;

class Solution {
    // 用于维护堆的性质
    void heapAdjust(vector<int>& arr, int n, int i) {
        while (true) {
            int largest = i;   // 假设当前节点是最大的
            int left = 2 * i + 1;   // 左子节点的索引
            int right = 2 * i + 2;   // 右子节点的索引

            // 如果左子节点存在且大于当前最大节点，则更新最大节点
            if (left < n && arr[left] > arr[largest]) largest = left;
            // 如果右子节点存在且大于当前最大节点，则更新最大节点
            if (right < n && arr[right] > arr[largest]) largest = right;

            // 如果最大节点仍然是当前节点，说明堆已经满足性质，退出循环
            if (largest == i) {
                break;
            }
            // 否则，交换当前节点和最大节点
            swap(arr[i], arr[largest]);
            // 更新当前节点为最大节点的位置，继续维护堆的性质
            i = largest;
        }
    }

public:
    void my_heap_sort(vector<int>& arr) {   
        int n = arr.size();

        // 构建堆
        for (int i = n / 2 - 1; i >= 0; i--) {   // 从最后一个非叶子节点（n / 2 - 1）开始，向上维护堆的性质
            heapAdjust(arr, n, i);
        }

        // 排序
        for (int i = n - 1; i > 0; i--) {
            // 将堆顶元素（最大值）与最后一个元素交换
            swap(arr[0], arr[i]);
            // 重新维护堆的性质，但不包括最后一个元素（已经排序好的部分）
            heapAdjust(arr, i, 0);
        }
    }
};

int main() {
    Solution s;
    vector<int> arr = { 170, 45, 75, 90, 802, 24, 2, 66 };
    cout << "before sorted: ";
    for (int i = 0; i < arr.size(); i++) {
        cout << arr[i] << " ";
    }
    cout << endl;

    s.my_heap_sort(arr);
    cout << "after sorted: ";
    for (int i = 0; i < arr.size(); i++) {
        cout << arr[i] << " ";
    }
    cout << endl;
    return 0;
}
```

## 总结

| 排序算法     | 平均时间复杂度 | 最佳情况   | 最坏情况   | 空间复杂度 | 稳定性 | 排序方式 |
|-------------|----------------|------------|------------|------------|--------|----------|
| 冒泡排序     | O(n²)          | O(n)       | O(n²)      | O(1)       | 稳定   | 内排序   |
| 选择排序     | O(n²)          | O(n²)      | O(n²)      | O(1)       | 不稳定 | 内排序   |
| 插入排序     | O(n²)          | O(n)       | O(n²)      | O(1)       | 稳定   | 内排序   |
| 希尔排序     | O(n log n)     | O(n log² n)| O(n log² n)| O(1)       | 不稳定 | 内排序   |
| 归并排序     | O(n log n)     | O(n log n) | O(n log n) | O(n)       | 稳定   | 外排序   |
| 快速排序     | O(n log n)     | O(n log n) | O(n²)      | O(log n)   | 不稳定 | 内排序   |
| 堆排序       | O(n log n)     | O(n log n) | O(n log n) | O(1)       | 不稳定 | 内排序   |
| 基数排序     | O(n × k)       | O(n × k)   | O(n × k)   | O(n + k)   | 稳定   | 外排序   |

