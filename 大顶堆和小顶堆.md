# **大顶堆与小顶堆详解：原理、实现与应用**

## **一、堆的基本概念**
堆（Heap）是一种特殊的**完全二叉树**，满足以下性质：
- **结构性**：所有层级除最后一层外都是满的，最后一层节点靠左排列
- **堆序性**：
  - **大顶堆（Max-Heap）**：父节点值 ≥ 子节点值
  - **小顶堆（Min-Heap）**：父节点值 ≤ 子节点值

## **二、核心特性对比**
| 特性               | 大顶堆                          | 小顶堆                          |
|--------------------|--------------------------------|--------------------------------|
| **堆顶元素**       | 最大值                         | 最小值                         |
| **典型应用**       | 求前K大元素                    | 求前K小元素                    |
| **C++默认堆**      | `priority_queue<T>`（大顶堆）  | `priority_queue<T, vector<T>, greater<T>>` |
| **比较规则**       | 父节点 ≥ 子节点                | 父节点 ≤ 子节点                |

## **三、堆的实现原理**
### **1. 存储方式**
堆通常用**数组**实现，利用完全二叉树的性质：
- 对于节点`i`（从0开始）：
  - 父节点：`(i-1)/2`
  - 左子节点：`2*i + 1`
  - 右子节点：`2*i + 2`

```cpp
// 大顶堆示例
vector<int> max_heap = {9, 5, 7, 2, 3};
//       9
//     /   \
//    5     7
//   / \
//  2   3
```

### **2. 关键操作**
#### **（1）插入元素（上浮）**
1. 将新元素放到数组末尾
2. 与父节点比较，若违反堆序性则交换
3. 重复直到满足堆序性

```cpp
void push_max_heap(vector<int>& heap, int val) {
    heap.push_back(val);
    int i = heap.size() - 1;
    while (i > 0 && heap[(i-1)/2] < heap[i]) {  // 大顶堆上浮
        swap(heap[i], heap[(i-1)/2]);
        i = (i-1)/2;
    }
}
```

#### **（2）删除堆顶（下沉）**
1. 将堆顶与末尾元素交换
2. 删除末尾元素
3. 从堆顶开始与较大（小顶堆为较小）的子节点交换，直到满足堆序性

```cpp
void pop_max_heap(vector<int>& heap) {
    swap(heap[0], heap.back());
    heap.pop_back();
    int i = 0, n = heap.size();
    while (true) {
        int left = 2*i + 1, right = 2*i + 2;
        int largest = i;
        if (left < n && heap[left] > heap[largest]) largest = left;  // 大顶堆比较
        if (right < n && heap[right] > heap[largest]) largest = right;
        if (largest == i) break;
        swap(heap[i], heap[largest]);
        i = largest;
    }
}
```

## **四、C++中的堆实现**
### **1. `priority_queue`用法**
```cpp
#include <queue>
// 大顶堆（默认）
priority_queue<int> max_heap;  
// 小顶堆
priority_queue<int, vector<int>, greater<int>> min_heap;  
```

### **2. 自定义比较器**
```cpp
// 大顶堆（按pair的second降序）
struct Compare {
    bool operator()(const pair<int,int>& a, const pair<int,int>& b) {
        return a.second < b.second;  // 注意符号方向！
    }
};
priority_queue<pair<int,int>, vector<pair<int,int>>, Compare> custom_heap;
```

## **五、典型应用场景**
### **1. 大顶堆应用**
- **LeetCode 215. 数组中的第K个最大元素**
  ```cpp
  int findKthLargest(vector<int>& nums, int k) {
      priority_queue<int> max_heap(nums.begin(), nums.end());
      while (--k) max_heap.pop();  // 移除前k-1个
      return max_heap.top();
  }
  ```

### **2. 小顶堆应用**
- **LeetCode 347. 前K个高频元素**
  ```cpp
  vector<int> topKFrequent(vector<int>& nums, int k) {
      unordered_map<int,int> freq;
      for (int num : nums) freq[num]++;
      
      priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> min_heap;
      for (auto& [num, count] : freq) {
          min_heap.push({count, num});
          if (min_heap.size() > k) min_heap.pop();
      }
      
      vector<int> res;
      while (!min_heap.empty()) {
          res.push_back(min_heap.top().second);
          min_heap.pop();
      }
      return res;
  }
  ```

## **六、复杂度分析**
| 操作       | 时间复杂度  | 空间复杂度 |
|------------|------------|------------|
| 建堆       | O(n)       | O(n)       |
| 插入元素   | O(log n)   | O(1)       |
| 删除堆顶   | O(log n)   | O(1)       |
| 获取堆顶   | O(1)       | O(1)       |

## **七、常见问题**
### **Q1：如何选择大顶堆还是小顶堆？**
- 需要**最大值**或**前K大** → 大顶堆
- 需要**最小值**或**前K小** → 小顶堆

### **Q2：为什么优先队列默认是大顶堆？**
C++的`priority_queue`使用`less<T>`比较器，其实现为：
```cpp
template <class T> struct less {
    bool operator()(const T& a, const T& b) const { return a < b; }
};
```
这实际上使得更大的元素优先级更高。

---
