# 复合类型

## 一、指针和引用

### 1.new和delete

#### new

在堆上动态分配空间，创建对象，并返回对象的地址。返回的地址保存在指针变量中。new表达式有三种形式。

1. 用于分配特定类型的单个对象

```cpp
new 类型
// 或者
new 类型(初始值)

// 例如：
int* ip1 = new int;
*ip1 = 512;
int* ip2 = new int(100);
```

2. 在堆上分配指定类型和大小的数组，并返回数组的首地址，但是不能对数组进行显式的初始化。

```cpp
new 类型[数组大小]

// 例如：
int* ipa = new int[100];
```

3. 将对象创建在已经分配好的内存中，这种形式被称为**定位new**表达式。

```cpp
new (指针)类型

// 在指针指定的空间中创建一个指定类型的对象，可以预先分配大量的内存，通过定位new表达式在这段内存中创建对象。例如：
#include <iostream>
#include <new>

using namespace std;

char* buf = new char[1000];

int main() {
    int* ip = new (buf) int;   // 在buf中创建一个int对象，此时不再重新从堆上分配空间
}
```

#### delete

1. 释放new分配的单个对象

```cpp
delete 指针

// 例如：
int* ip1 = new int;
*ip1 = 512;
delete ip1;
```

2. 释放new分配的数组

```cpp
delete [] 指针

// 例如：
int* ipa = new int[100];
delete [] ipa;
```

### 2.引用

#### 左值引用

引用又称**别名**，引用**必须初始化**。

引用一旦初始化，就不能再绑定到其他的对象，对引用的所有操作都会被应用在它所绑定的对象上。

#### 右值引用

```cpp
类型 &&右值引用变量 = 右值表达式
```

### 3.const 限定指针和引用

- 不允许将const地址赋值给非const指针
- const int 是一个指向常量的指针，但其本身的值可以改变，指向另一个const int
- 允许将一个非 const 地址赋值给 const 指针

1. 指向常量的指针

```cpp
const int val = 1024;
const int* ip = &val;

int val = 1024;
const int* ip = &val;
```

2. 指向非const对象的const指针

```cpp
int val = 1024;
int* const ip = &val;
```

3. 指向const对象的const指针

```cpp
const int val = 1024;
const int* const ip = &val;
```

4. const 限定引用

5. volatile 限定词

## 二、结构体、联合、枚举

1. 结构体struct

```cpp
struct 结构体类型名 {
    成员声明;
};   // 注意这里有一个分号
```

结构体的成员不能独立使用，必须由结构体类型的变量通过成员选择符“.”来选择，或者由结构体类型的指针通过“->”运算符来选择。

一般编译器对于结构体使用“边界对齐技术”，以空间换取时间。

2. 联合union

语法与 struct 类似，只有数据成员的存储方式不同。union 的每个成员都从联合变量的首地址开始存储，每次只能使用一个成员，节省空间但容易出错。

3. 枚举enum

未指定值的枚举成员，编译器会赋给它相邻的下一个整数值。

## 三、内置数组

### 数组与指针

数组名字代表数组第一个元素的地址。

C++11引入了两个库函数begin()和end()，在头文件\<iterator>中定义，用法为：

```cpp
begin(数组名);
end(数组名);
```

函数返回值分别指向：数组第一个元素的指针，数组最后一个元素的下一个位置的指针。

### C风格字符串的函数

效率和安全性都不足，C++标准库的string类提供更好的。

## 四、标准数据库string

使用string类要包含头文件\<string>

不熟悉的函数总结

```cpp
string str(n, 'c');   // 把s初始化为由连续n个字符c组成的串

// 读写string对象
// cin输入字符串，会略过前导空白，遇到空白停止
// 读取输入流中的单词，直到文件结束
string world;
while (cin >> world) {   // 反复读取单词，直到遇见文件末尾
    cout << world << endl;   // 逐个输出单词，每行一个
}
// getline()能够在读取的字符串中保留输入的空白字符
getline(is, s);   // 从输入流is中读取一行赋给s，返回is
// 每次读取一行文本，直到文件结束
string line;
while (getline(cin, line)) {
    cout << line << endl;
}

// 转换
s.c_str();    // 返回s中内容对应的C风格字符串首地址 
```

## 五、标准库类型vector

表示对象的集合，这种容纳着其他对象的对象被称为**容器**。vector是长度可变的向量。使用时必须包含头文件\<vector>。

同类型的vector之间可以直接赋值，也可以用一个vector初始化另一个vector。

一些常用方法

```cpp
// 初始化
vector<T> v1
vector<T> v2(v1)   // v2中包含v1所有元素的副本
vector<T> v2 = v1   // 等价于v2(v1)
vector<T> v3(n, value)
vector<T> v4(n)
vector<T> v5{a, b, c, ...}
vector<T> v6 = {a, b, c, ...}

// 操作
v.empty()
v.size()
v.push_back()
v.pop_back()
v.at(n)   // 返回v中第n个位置上元素的引用，下标越界抛出异常
```

注意：不能用下标运算符向vector中添加元素，下标运算符只能访问已经存在的元素。

## 六、迭代器

迭代器类似于指针类型，提供对对象的**间接访问**。迭代器在**容器或string对象**上使用。

标准库容器用**iterator**和**const_iterator**表示迭代器的类型。

```cpp
vector<int>::iterator it1;
vector<string>::iterator it2;
string::iterator it3;
vector<int>::const_iterator it4;
string::const_iterator it5;
```

## 七、文件数据处理

### 文件读写

1. 输入输出重定向

例如可执行文件名为app.exe，那么

- 从标准输入读取数据，运行结果写到标准输出设备
```c:\> app```
-  输入重定向，标准输出
```c:\> app <numbers.txt```
- 输入输出重定向
```c:\> app <numbers.txt >output.txt```

2. 标准库文件流

头文件\<fstream>中的ifstream，ofstream，fstream（istream，ostream，iostream的派生类）。

### 字符串流

头文件\<sstream>中的istringstream，ostringstream，stringstream（istream，ostream，iostream的派生类）。
