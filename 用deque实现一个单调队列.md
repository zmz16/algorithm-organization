# 单调队列的实现

## **单调队列的核心思想**
1. **队列特性**：
   - 维护一个**单调递减队列**（队头是当前窗口最大值）。
   - 队列中只保留**可能成为未来窗口最大值的元素**（剔除无用元素）。
   
2. **操作规则**：
   - **`push(value)`**：
     - 从队尾开始，移除所有小于 `value` 的元素（保持单调递减）。
     - 将 `value` 加入队尾。
   - **`pop(value)`**：
     - 如果窗口移出的元素 `value` 等于队头元素，弹出队头（因为它已离开窗口）。

3. **时间复杂度**：
   - 每个元素最多入队、出队一次 → **O(n)**。

## **实现步骤**
1. **初始化**：双端队列 `deque` 和结果数组 `res`。
2. **遍历数组**：
   - 移除窗口外的元素（`pop` 规则）。
   - 将当前元素按 `push` 规则加入队列。
   - 记录当前窗口最大值（队头元素）。
3. **返回结果**：`res` 存储每个窗口的最大值。

## **关键点**
- **单调队列不是排序的**，而是按规则动态维护候选最大值。
- **`deque` 的优势**：支持高效的头尾插入/删除（`O(1)`）。

## **示例**
- **输入**：`nums = [1,3,-1,-3,5,3,6,7]`, `k = 3`
- **过程**：
  - 窗口 `[1,3,-1]` → 队列 `[3,-1]` → 最大值 `3`
  - 窗口 `[3,-1,-3]` → 队列 `[3,-1,-3]` → 最大值 `3`
  - 窗口 `[-1,-3,5]` → 队列 `[5]` → 最大值 `5`
  - ...（依此类推）
- **输出**：`[3,3,5,5,6,7]`

## **代码实现（C++）**
```cpp
class MyQueue {
public:
    deque<int> que;   // 双端队列，支持两边插入删除

    // 每次弹出的时候，比较当前要弹出的数值是否等于队列出口元素的数值，如果相等则弹出。
    // 同时pop之前判断队列当前是否为空。
    void pop (int val) {
        if ( ! que.empty() && val == que.front()) {
            que.pop_front();
        }
    }

    // 如果push的数值大于入口元素的数值，那么就将队列后端的数值弹出，直到push的数值小于等于队列入口元素的数值为止。
    // 这样就保持了队列里的数值是单调从大到小的了。
    void push (int val) {
        while ( ! que.empty() && val > que.back()) {
            que.pop_back();
        }
        que.push_back(val);
    }

    // 查询当前队列里的最大值 直接返回队列前端也就是front就可以了。
    int front () {
        return que.front();
    }
}
```

## **总结**
- **单调队列**：高效维护滑动窗口极值的利器。
- **核心技巧**：通过 `push`/`pop` 规则动态剔除无用元素，保证队头始终是当前最大值。
- **适用场景**：需要高效获取区间最值的滑动窗口问题。