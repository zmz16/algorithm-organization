# 拓扑排序

**给出一个 有向图，把这个有向图转成线性的排序 就叫拓扑排序**。

当然拓扑排序也要检测这个有向图 是否有环，即存在循环依赖的情况，因为这种情况是不能做线性排序的。

所以**拓扑排序也是图论中判断有向无环图的常用方法**。

**当我们做拓扑排序的时候，应该优先找 入度为 0 的节点，只有入度为0，它才是出发节点**。

## 步骤

1. 找到入度为0 的节点，加入结果集
2. 将该节点从图中移除

循环以上两步，直到 所有节点都在图中被移除了。

结果集的顺序，就是我们想要的拓扑排序顺序 （结果集里顺序可能不唯一）

## 如果有 有向环怎么办呢？

如果我们发现**结果集元素个数 不等于 图中节点个数**，我们就可以认定图中一定有 有向环

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <unordered_map>
#include <queue>

using namespace std;

int main() {
	int n, m, s, t;   // 文件和依赖关系
	cin >> n >> m;

	vector<int> inDegree(n, 0);   // 记录入度
	unordered_map<int, vector<int>> umap;   // 记录依赖关系
	vector<int> result;   // 记录结果

	while (m--) {
		cin >> s >> t;
		inDegree[t]++;   // 统计入度
		umap[s].push_back(t);   // 记录依赖关系
	}

	// 定义一个队列,存储入度为0的节点,依次进行处理
	queue<int> que;
	for (int i = 0; i < n; i++) {
		if (inDegree[i] == 0) {
			que.push(i);
		}
	}

	// 不断遍历队列的元素
	while (!que.empty()) {
		int cur = que.front();
		que.pop();
		result.push_back(cur);
		vector<int> files = umap[cur];   // //获取该文件指向的文件
		if (files.size()) {    // cur有后续文件
			for (int j = 0; j < umap[cur].size(); j++) {
				inDegree[files[j]]--;
				if (inDegree[files[j]] == 0) {
					que.push(files[j]);
				}
			}
		}
	}

	if (result.size() == n) {
		for (int i = 0; i < n - 1; i++) {
			cout << result[i] << " ";
		}
		cout << result[result.size() - 1] << endl;
	}
	else {
		cout << -1 << endl;
	}
	
	return 0;
}
```